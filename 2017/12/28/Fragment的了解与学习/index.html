<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Fragment的了解与学习 | Xiey94</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Fragment的用途：1、为平板做适配、正常手机是宽度小于长度，平板则相反，当然这个判断方法并不保险，因为当手机翻转的时候，手机配置发生变化，导致的结果就是长宽大小比改变，这时候如果手机当平板用，感人感觉应该体验不佳； 2、首页多BottomTab的，这种软件布局比较常见，像贴吧、QQ、微信、微博、支付宝等都是这样的开头布局（里面的不讲吼），一个主Activity，然后动态切换四个左右的frag">
<meta name="keywords" content="android">
<meta property="og:type" content="article">
<meta property="og:title" content="Fragment的了解与学习">
<meta property="og:url" content="http://yoursite.com/2017/12/28/Fragment的了解与学习/index.html">
<meta property="og:site_name" content="Xiey94">
<meta property="og:description" content="Fragment的用途：1、为平板做适配、正常手机是宽度小于长度，平板则相反，当然这个判断方法并不保险，因为当手机翻转的时候，手机配置发生变化，导致的结果就是长宽大小比改变，这时候如果手机当平板用，感人感觉应该体验不佳； 2、首页多BottomTab的，这种软件布局比较常见，像贴吧、QQ、微信、微博、支付宝等都是这样的开头布局（里面的不讲吼），一个主Activity，然后动态切换四个左右的frag">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://img.blog.csdn.net/20140719225005356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20171228155917067">
<meta property="og:updated_time" content="2017-12-28T09:13:31.296Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fragment的了解与学习">
<meta name="twitter:description" content="Fragment的用途：1、为平板做适配、正常手机是宽度小于长度，平板则相反，当然这个判断方法并不保险，因为当手机翻转的时候，手机配置发生变化，导致的结果就是长宽大小比改变，这时候如果手机当平板用，感人感觉应该体验不佳； 2、首页多BottomTab的，这种软件布局比较常见，像贴吧、QQ、微信、微博、支付宝等都是这样的开头布局（里面的不讲吼），一个主Activity，然后动态切换四个左右的frag">
<meta name="twitter:image" content="http://img.blog.csdn.net/20140719225005356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
  
    <link rel="alternate" href="/atom.xml" title="Xiey94" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xiey94</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Why should our days leave us never to return</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Fragment的了解与学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/Fragment的了解与学习/" class="article-date">
  <time datetime="2017-12-28T09:10:53.000Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fragment的了解与学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Fragment的用途："><a href="#Fragment的用途：" class="headerlink" title="Fragment的用途："></a>Fragment的用途：</h3><p>1、为平板做适配、正常手机是宽度小于长度，平板则相反，当然这个判断方法并不保险，因为当手机翻转的时候，手机配置发生变化，导致的结果就是长宽大小比改变，这时候如果手机当平板用，感人感觉应该体验不佳；</p>
<p>2、首页多BottomTab的，这种软件布局比较常见，像贴吧、QQ、微信、微博、支付宝等都是这样的开头布局（里面的不讲吼），一个主Activity，然后动态切换四个左右的fragment，达到一种快速的感觉，毕竟Activity的创建还是很沉重的；</p>
<blockquote>
<p>那么话说回来，这种效果到底是如何的呢？熟悉Android的朋友一定都会知道，很简单嘛，使用TabHost就OK了！但是殊不知，TabHost并非是那么的简单，它的可扩展性非常的差，不能随意地定制Tab项显示的内容，而且运行还要依赖于ActivityGroup。ActivityGroup原本主要是用于为每一个TabHost的子项管理一个单独的Activity，但目前已经被废弃了。</p>
</blockquote>
<p>3、为了丝滑体验，用单Activity+多Fragment的组合，这种时候就要深入的理解Fragment了，不然出了问题就不太好挽回，同时这也是我所向往的；</p>
<p>目前我们想到的主要是这3个。</p>
<h3 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h3><p>这个是始终逃不掉的，正是有了和Activity差不多的生命周期才显得如此精彩</p>
<p><img src="http://img.blog.csdn.net/20140719225005356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处输入图片的描述"></p>
<p>说实话，我是很讨厌别人一上来就讲生命周期的，当我刚开始接触Android的时候，买了一本书来学习，结果第一章节就给我讲生命周期，但是当时不懂，听作者说这个生命周期太重要了，唬的我不得不看，但是我一个菜鸟看这个干嘛，我当时迫不及待的想搞个登录界面出来，找点兴趣和成就感。后来，我也学了很长时间的android之后（基础阶段），我用到的生命周期很少，只是普通的自动创建onCreate，然后普通的使用一个Activity，因为我才弄懂TextView、EditText等，我还用不到生命周期。有一天当我终于被一个demo给迷住的时候，我才发现生命周期的厉害，然后我才真正的去看Activity的生命周期，去看他们的先后顺序，作用，以及能利用生命周期函数做什么，所以我是很反感的，所以当我第一次接触Fragment的时候，发现竟然也有生命周期，而且比Activity还多，我就恼怒了，然后直接弃之生命周期去看别的，以至于在我人生第一次面试中，要默写生命周期函数的名称。。。</p>
<p>我还是这个态度，当你真正想了解Fragment的生命周期函数的时候再来关注，不然你看了没什么用，还一时半会记不住，自寻烦恼，就算你记住了，用不到精妙住处也是徒劳。</p>
<p>但我接触了fragment很久以后，也是在体会到生命周期的重要性之后，我就一直想搞清楚这个生命周期函数分别是在什么时候调用的，于是，我就测试了一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">12-27 03:03:04.889 5393-5393/com.xiey94.fragment E/ccer: Activity----onCreate</span><br><span class="line">12-27 03:03:04.891 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onAttach</span><br><span class="line">12-27 03:03:04.891 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onCreate</span><br><span class="line">12-27 03:03:04.891 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onCreateView</span><br><span class="line">12-27 03:03:04.894 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onViewCreated</span><br><span class="line">12-27 03:03:04.894 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onActivityCreated</span><br><span class="line">12-27 03:03:04.894 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onViewStateRestored</span><br><span class="line">12-27 03:03:04.895 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onStart</span><br><span class="line">12-27 03:03:04.895 5393-5393/com.xiey94.fragment E/ccer: Activity----onStart</span><br><span class="line">12-27 03:03:04.895 5393-5393/com.xiey94.fragment E/ccer: Activity----onResume</span><br><span class="line">12-27 03:03:04.895 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onResume</span><br><span class="line">12-27 03:03:16.422 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onPause</span><br><span class="line">12-27 03:03:16.422 5393-5393/com.xiey94.fragment E/ccer: Activity----onPause</span><br><span class="line">12-27 03:03:17.169 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onStop</span><br><span class="line">12-27 03:03:17.170 5393-5393/com.xiey94.fragment E/ccer: Activity----onStop</span><br><span class="line">12-27 03:03:17.170 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onDestroyView</span><br><span class="line">12-27 03:03:17.170 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onDestroy</span><br><span class="line">12-27 03:03:17.170 5393-5393/com.xiey94.fragment E/ccer: Fragemnt----onDetach</span><br><span class="line">12-27 03:03:17.170 5393-5393/com.xiey94.fragment E/ccer: Activity----onDestroy</span><br></pre></td></tr></table></figure>
<p>可以从测试中看到先后顺序，先后顺序很重要，可以帮助我们准确的在哪个阶段该干什么；</p>
<p>知道了调用顺序后就紧接着应该知道，都是在什么时候回调的，这个了解了才算是真正的知道在哪个阶段该干什么；</p>
<p><strong> onAttach:</strong><br>当Fragment依附到Activity的时候调用<br>可以获取到依附的Activity的实例；当api-23及以后，会显示onAttach(Activity activity)是过时的，要使用onAttach(Context context)；</p>
<p><strong> onCreate：</strong><br>在Fragment初始化的时候调用，可以再该方法中使用getArgument获取activity出过来的fragment的参数，这个时候还不能获取<font color="red">activity中的控件</font>，因为Activity还没又onCreate完成。</p>
<p><strong> onCreateView:</strong><br>可以通过布局填充器来获取fragment的布局，同时可初始化fragment中的控件。（我之前都是不关注fragment的生命周期的，关于初始化操作，我都是全部扔到这里面操作的）</p>
<p><strong> onViewCreate:</strong><br>当onCreateView调用完成之后立即执行，可以在这里面赋值;onViewCreated(View view,Bundle savedInstanceState)，这个里面的View就是onCreateView中最后返回的View，可以在这里面进行初始化fragment的控件并赋值；个人感觉相对普通功能来说是和onCreateView重了，但是在特殊场景下肯定有意外收获，当然 我还没有遇到。</p>
<p><strong> onActivityCreate:</strong><br>这个就是Activity的onCreate方法执行完了，此时就可以获取Activity中的控件资源了。</p>
<p><strong> onViewStateRestored:</strong></p>
<p><strong> onStart:</strong><br>我在网上看到有的博客说这个方法是在Activity的onStart执行之后立刻执行的，但是根据我打印的结果来看，好像他要比Activity的onStart要先执行；这个方法执行完fragment界面就显示出来了，但是现在还没有获取到焦点，用户是还不能进行操作体验的。</p>
<p><strong> onResume:</strong><br>用户可操作了</p>
<p><strong> onPause:</strong><br>可见，失去焦点，（上面弹出一个Dialog）</p>
<p><strong> onStop:</strong><br>不可见，上面覆盖了一个fragment或者退出前夕</p>
<p><strong> onDestroyView:</strong><br>fragment视图被销毁，fragment视图被回收</p>
<p><strong> onDestroy:</strong><br>这个fragment不再使用了，但资源没有回收，还是可以在Activity中找到的</p>
<p><strong> onDetach:</strong><br>与Activity接触依附关系，fragment资源被回收。</p>
<p>额外的回调方法：<br><strong> onHiddenChanged</strong><br>当Fragment调用hide、show时回调</p>
<p><strong> setUserVisibleHint</strong><br>当Fragment与ViewPager结合使用时，切换Pager时回调</p>
<p>特别说明：<br>1、onAttach和onCreate只在Fragment与Activity第一次关联时调用；<br>2、onDestroy和onDetach只在Fragment与Activity销毁时才会被调用；<br>3、addToBackStack只涉及onCreateView和onDestroyView这之间的生命周期；add和replace不会对Fragment的生命周期产生影响，但add会造成Fragment叠加显示；<br>4、Fragment和ViewPager结合时使用时的生命周期与4相似；<br>5、通过hide、show来显示和隐藏Fragment，此时Fragment只改变了可见性，并不涉及生命周期的改变；</p>
<h3 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h3><p>1、创建一个普通的xml文件；<br>2、创建一个Class继承自Fragment，并填充加载创建的xml文件；<br>3、在Activity中显示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#7722aa&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:clickable=&quot;true&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/testView&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;fragment1&quot;</span><br><span class="line">        android:textColor=&quot;#ff4466&quot;</span><br><span class="line">        android:textSize=&quot;30sp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Fragment2 extends Fragment &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        return inflater.inflate(R.layout.fragment2, container, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager fm=getSupportFragmentManager();</span><br><span class="line">FragmentTransaction ft=fm.beginTransaction();</span><br><span class="line">Fragment2 fragment2=new Fragment2();</span><br><span class="line">ft.replace(R.id.rootContent,fragment2);</span><br><span class="line">ft.commit();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/ll&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#ff33aa&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/rootContent&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>以上这一段代码应该不用解释，他是最普通的demo案例。</p>
<p>Fragment的堆栈管理器FragemntManager：用于对Fragment的堆栈管理；getFragmentManager() // v4中，getSupportFragmentManager<br>FragmentTransaction事务，学过数据库就应该知道（程序员都学过吧），在事务中进行操作，最后提交事务。</p>
<p>因为版本的问题，Android3.0以下的版本，需要引入v4的包；一旦决定用了v4的就不能用app，反之亦然，不然改死你。</p>
<p>主要的操作是事务的操作：</p>
<p><strong> ft.add</strong><br>往Activity中添加一个fragment</p>
<p><strong> ft.remove</strong><br>从Activity中移除一个Fragment，如果被移除的这个Fragment没有添加到回退栈中，它的实例将会被销毁；</p>
<p><strong> ft.replace</strong><br>使用另一个fragment替换当前的fragment；实际上就是remove之后add的合体</p>
<p><strong> ft.hide</strong><br>隐藏当前的fragment，晶晶是不可见，并不会销毁；</p>
<p><strong> ft.show</strong><br>显示之前隐藏的fragment</p>
<p>额外的API：</p>
<p><strong> detach</strong><br>会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护。</p>
<p><strong> attach</strong><br>重建view视图，附加到UI上并显示。</p>
<p>测试：<br>为了多了解一点事务操作，写了一个不成熟的demo用来测试add、show、hide</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.xiey94.fragment.test3;</span><br><span class="line"></span><br><span class="line">import android.support.v4.app.FragmentManager;</span><br><span class="line">import android.support.v4.app.FragmentTransaction;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line"></span><br><span class="line">import com.xiey94.fragment.R;</span><br><span class="line"></span><br><span class="line">public class Test3Activity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private FragmentManager fm;</span><br><span class="line">    private Fragment31 fragment31;</span><br><span class="line">    private Fragment32 fragment32;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test3);</span><br><span class="line"></span><br><span class="line">        fm = getSupportFragmentManager();</span><br><span class="line"></span><br><span class="line">        FragmentTransaction ft = fm.beginTransaction();</span><br><span class="line">        fragment31 = new Fragment31();</span><br><span class="line">        ft.add(R.id.rootViewGroup, fragment31);</span><br><span class="line">        ft.commit();</span><br><span class="line"></span><br><span class="line">        Button btn1 = (Button) findViewById(R.id.btn1);</span><br><span class="line">        btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                FragmentTransaction ft = fm.beginTransaction();</span><br><span class="line">                if (fragment31 == null) &#123;</span><br><span class="line">                    fragment31 = new Fragment31();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (fragment31.isAdded()) &#123;</span><br><span class="line">                    if (fragment32 != null) &#123;</span><br><span class="line">                        ft.hide(fragment32).show(fragment31);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ft.show(fragment31);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ft.add(R.id.rootViewGroup, fragment31);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ft.commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Button btn2 = (Button) findViewById(R.id.btn2);</span><br><span class="line">        btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                FragmentTransaction ft = fm.beginTransaction();</span><br><span class="line">                if (fragment32 == null) &#123;</span><br><span class="line">                    fragment32 = new Fragment32();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (fragment32.isAdded()) &#123;</span><br><span class="line">                    if (fragment31 != null) &#123;</span><br><span class="line">                        ft.hide(fragment31).show(fragment32);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ft.show(fragment32);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ft.add(R.id.rootViewGroup, fragment32);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ft.commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么有这么多的if-else，开始我写的也是很少的，然后测试过来一路修改的：<br>1、当fragment被add之后就不能再add了；<br>2、第一个判断null，是避免创建过多实例，第二个判断null，是避免为null；<br>3、当我不停的切换fragment1和fragment2时，被回调的是他们俩的onHiddenChanged，所以他们的用户操作行为还是保存的；<br>4、如果不希望保存用户操作，那就用remove-add或replace来操作；<br>5、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。</p>
<p>关于attach()和detach()我不是很懂，从别人那找了找：</p>
<blockquote>
<p>使用add()加入fragment时将触发onAttach(),使用attach()不会触发onAttach()</p>
<p>使用replace()替换后会将之前的fragment的view从viewtree中删除</p>
<p>触发顺序:</p>
<p>detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView()</p>
<p>attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()</p>
<p>使用hide()方法只是隐藏了fragment的view并没有将view从viewtree中删除,随后可用show()方法将view设置为显示</p>
<p>而使用detach()会将view从viewtree中删除,和remove()不同,此时fragment的状态依然保持着,在使用attach()时会再次调用onCreateView()来重绘视图,注意使用detach()后fragment.isAdded()方法将返回false,在使用attach()还原fragment后isAdded()会依然返回false(需要再次确认)</p>
<p>执行detach()和replace()后要还原视图的话, 可以在相应的fragment中保持相应的view,并在onCreateView()方法中通过view的parent的removeView()方法将view和parent的关联删除后返回</p>
</blockquote>
<p>6、我的感觉：对比来看；attach和add对比：一个重建视图，一个重建实例 ；detach和remove的区别：一个销毁视图，一个直接销毁实例；但是我还没想到他们的使用场景。</p>
<p>add或者replace只是添加到任务，如果立即执行得加上executePendingTransactions。</p>
<h3 id="回退栈"><a href="#回退栈" class="headerlink" title="回退栈"></a>回退栈</h3><p>要想达到一个Activity+多个Fragment的效果，回退栈肯定是少不了的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction.addToBackStack(String)</span><br></pre></td></tr></table></figure>
<p>1、添加回退栈后，remove这个操作就不会直接销毁实例，而是会添加到回退栈中，再次回退的时候，会重新创建视图；</p>
<p>疑问：hide和show与回退栈有关系吗？</p>
<p>个人感觉好像没关系啊！add、remove、replace等操作都是针对实例的操作，也就是在add/remove/replace操作后要是添加了回退栈，就将他们的实例添加到管理栈中，前进或后退分别进栈出栈；而hide-show只是给（假设都在栈里）那些视图披上/脱下一层隐身衣。</p>
<blockquote>
<p>跟踪回退栈的状态<br>我们通过实现OnBackStackChangedListener接口来实现回退栈状态跟踪，具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//implements接口</span><br><span class="line">public class XXX implements FragmentManager.OnBackStackChangedListener </span><br><span class="line">//实现接口所要实现的方法</span><br><span class="line">@Override</span><br><span class="line">public void onBackStackChanged() &#123;</span><br><span class="line">  //do whatevery you want</span><br><span class="line">&#125;</span><br><span class="line">//设置回退栈监听接口</span><br><span class="line">getSupportFragmentManager().addOnBackStackChangedListener(this);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>管理回退栈</p>
</blockquote>
<p><br></p>
<blockquote>
<p>(1).FragmentTransaction.addToBackStack(String)<br>将一个刚刚添加的Fragment加入到回退栈中</p>
</blockquote>
<p><br></p>
<blockquote>
<p>(2).getSupportFragmentManager().getBackStackEntryCount()<br>获取回退栈中的实体数量</p>
</blockquote>
<p><br></p>
<blockquote>
<p>(3).getSupportFragmentManager().popBackStack(String name, int flags)<br>根据name立刻弹出栈顶的fragment</p>
</blockquote>
<p><br></p>
<blockquote>
<p>(4).getSupportFragmentManager().popBackStack(int id, int flags)<br>根据id立刻弹出栈顶的fragment</p>
</blockquote>
<p>还有出栈多个的问题：<br><a href="http://blog.csdn.net/qq_16247851/article/details/52793061" target="_blank" rel="noopener">Fragment 出栈的方法popBackStack需要特别注意的一点</a></p>
<blockquote>
<p>popBackStack(String tag,int flags)</p>
<p>tag可以为null或者相对应的tag，flags只有0和1(POP_BACK_STACK_INCLUSIVE)两种情况</p>
<p>如果tag为null，flags为0时，弹出回退栈中最上层的那个fragment。</p>
<p>如果tag为null ，flags为1时，弹出回退栈中所有fragment。</p>
<p>如果tag不为null，那就会找到这个tag所对应的fragment，flags为0时，弹出该fragment以上的Fragment，如果是1，弹出该fragment（包括该fragment）以上的fragment。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>popBackStack(int id,int flags)</p>
<p>与popBackStack(String tag,int flags)类似，找到id代表的fragment，然后执行一样的操作</p>
</blockquote>
<p><br></p>
<blockquote>
<p>popBackStackImmediate(int id, int flags)</p>
<p>popBackStackImmediate(String name, int flags)</p>
<p>popBackStackImmediate()</p>
<p>这几个方法类似以上的方法，只不过这几个在内部调用时会立即弹出</p>
</blockquote>
<h3 id="Activity异常销毁"><a href="#Activity异常销毁" class="headerlink" title="Activity异常销毁"></a>Activity异常销毁</h3><p>配置发生改变，View重新绘制，导致Fragment也跟着重新绘制，onSaveInstanceState可以保存数据，然后在onCreate或者onCreateView或者onActivityCreated进行恢复都可以。</p>
<p>我尝试了一下销毁重建的demo，经过不断的调试后有一个可以正常销毁重建的：</p>
<p>fragment中我就放一个EditText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/editText&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Fragment41 extends Fragment &#123;</span><br><span class="line">    private EditText editText;</span><br><span class="line">    private View rootView;</span><br><span class="line">    public static final String TAG = &quot;Fragment41&quot;;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">        if (rootView == null) &#123;</span><br><span class="line">            rootView = inflater.inflate(R.layout.fragment41, container, false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewGroup parent = (ViewGroup) rootView.getParent();</span><br><span class="line">        if (parent != null) &#123;</span><br><span class="line">            parent.removeView(rootView);</span><br><span class="line">        &#125;</span><br><span class="line">        return rootView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        editText = view.findViewById(R.id.editText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState);</span><br><span class="line">        if (null != savedInstanceState) &#123;</span><br><span class="line">            editText.setText(savedInstanceState.getString(&quot;editText&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        super.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(&quot;editText&quot;, editText.getText().toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createView中创建视图，在ViewCreate中获取控件实例，在onSaveInstanceState中保存输入的数据，在onActivityCreated中获取数据，</p>
<p>activity的布局文件中就放了一个FrameLayout</p>
<p>Activity中：<br>一开始我就只是在onCreate中创建Fragment并提交后显示，但是翻转屏幕后保存的数据丢失了，然后我去打印Fragment的生命周期函数，发现开始的那几个Create、CreateView等前期函数调用了两次，百思不得其解，然后猜测就是创建了两个Fragment的实例，然后我在创建Fragment实例的时候加了一个==null的判断，但是依旧如此；也就是说，它依旧为null，这时我就不懂了，既然第一个已经是null了，那为什么还会执行两次呢？还没找到原因。</p>
<p>然后按照建议在Activity中去保存Fragment，然后重建之后获取Fragment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SaveStateActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Fragment41 fragment41;</span><br><span class="line">    private FragmentManager fm;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_save_state);</span><br><span class="line">        fm = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction ft = fm.beginTransaction();</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState != null) &#123;</span><br><span class="line">            fragment41 = (Fragment41) fm.getFragment(savedInstanceState, Fragment41.TAG);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fragment41 = new Fragment41();</span><br><span class="line">            ft.add(R.id.root, fragment41, Fragment41.TAG);</span><br><span class="line">            ft.commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123;</span><br><span class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">        fragmentManager.putFragment(outState, Fragment41.TAG, fragment41);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就OK了；</p>
<p><img src="http://img.blog.csdn.net/20171228155917067" alt="这里写图片描述"></p>
<h3 id="Fragment和Activity中通信"><a href="#Fragment和Activity中通信" class="headerlink" title="Fragment和Activity中通信"></a>Fragment和Activity中通信</h3><p>都推荐对外开放接口的方式，将Fragment 的一些对外操作传递给宿主 Activity。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class OneFragment extends Fragment implements View.OnClickListener&#123;</span><br><span class="line"></span><br><span class="line">    public interface IOneFragmentClickListener&#123;</span><br><span class="line">        void onOneFragmentClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        View contentView = inflater.inflate(R.layout.fragment_one, null);</span><br><span class="line">        contentView.findViewById(R.id.edt_one).setOnClickListener(this);</span><br><span class="line">        return contentView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        if (getActivity() instanceof IOneFragmentClickListener)&#123;</span><br><span class="line">             ((IOneFragmentClickListener) getActivity()).onOneFragmentClick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就可以看<a href="http://blog.csdn.net/lmj623565791/article/details/37992017" target="_blank" rel="noopener"> Android Fragment 真正的完全解析（下）</a></p>
<h3 id="Fragment是否很完美"><a href="#Fragment是否很完美" class="headerlink" title="Fragment是否很完美"></a>Fragment是否很完美</h3><p><a href="https://www.cnblogs.com/cr330326/p/5712022.html" target="_blank" rel="noopener">对于Fragment的一些理解</a></p>
<blockquote>
<p>因为Fragment是由FragmentManager来管理，每一个Activity有一个FragmentManager，管理着一个Fragment的栈，Activity是系统级别的，由系统来管理ActivityManager，栈也是系统范围的。而Fragment则是每个Activity范围内的，所以在使用Fragment的时候也有几点要注意。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>同一个Activity中，只能有一个ID或TAG标识的Fragment实例。<br>这很容易理解，同一个范围内，有标识的实例肯定是要唯一才行（否则还要标识干嘛）这个在布局中经常犯错，在布局中写Fragment最好不要加ID或者TAG，否则很容易出现不允许创建的错误。我的原则是如果放在布局中，就不要加ID和TAG，如果需要ID和TAG就全用代码控制。创建新实例前先到FragmentManager中查找一番，这也正是有标识的意义所在。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>一个Activity中有一个Fragment池，实例不一定会被销毁，可能会保存在池中。<br>这个跟第一点差不多。就好比系统会缓存Activity的实例一样，FragmentManager也会缓存Fragment实例，以方便和加速再次显示。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>FragmentManager的作用范围是整个Activity，所以，某一个布局ID，不能重复被Fragment替换。<br>通常显示Fragment有二种方式，一种是层叠到某个布局上，或者把某个布局上面的Fragment替换掉，但是这个布局不能出现二次，比如布局A中有ID为id的区域，要显示为Fragment，此布局A，只能在一个Activity中显示一个，否则第二个id区域不能被Fragment成功替换。因为虽有二个ID布局的实例，但ID是相同的，对FragmentManager来说是一样的，它会认为只有一个，因为它看的是布局的ID，而不是布局的实例。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>Fragment的生命周期反应Activity的生命周期。<br>Fragment在显示和退出时会走一遍完整的生命周期。此外，正在显示时，就跟Activity的一样，Activity被onPause，里面的Fragment就onPause，以此类推，由此带来的问题就是，比如你在onStart()里面做了一些事情，那么，当宿主Activity被挡住，又出现时（比如接了个电话），Fragment的onStart也会被高到，所以你要想到，这些生命周期不单单在显示和退出时会走到。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>Fragment的可见性。<br>这个问题出现在有Fragment栈的时候，也就是说每个Fragment不知道自己是否真的对用户可见。比如现在是Fragment A，又在其上面显示了FragmentB，当B显示后，A并不知道自己上面还有一个，也不知道自己对用户不可见了，同样再有一个C，B也不知。C退出后，B依然不知自己已在栈顶，对用户可见，B退后，A也不知。也就是说Fragment显示或者退出，栈里的其他Fragment无法感知。这点就不如Activity，a被b盖住后，a会走到onStop()，同样c显示后，b也能通过onStop()感知。Fragment可以从FragmentManager监听BackStackState的变化，但它只告诉你Stack变了，不告诉你是多了，还是少，还有你处的位置。有一个解决方案就是，记录页面的Path深度，再跟Fragment所在的Stack深度来比较，如果一致，那么这个Fragment就在栈顶。因为每个页面的Path深度是固定的，而Stack深度是不变化的，所以这个能准确的判断Fragment是否对用户可见，当然，这个仅针对整个页面有效，对于布局中的一个区域是无效的。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>Fragment的事件传递。<br>对于层叠的Fragment，其实就相当于在一个FrameLayout里面加上一堆的View，所以，如果处于顶层的Fragment没处理点击事件，那么事件就会向下层传递，直到事件被处理。比如有二个Fragment A和B，B在A上面，B只有TextView且没处理事件，那么点击B时，会发现A里的View处理了事件。这个对于Activity也不会发生，因为事件不能跨窗体传播，上面的Activity没处理事件，也不会传给下面的Activity，即使它可见。解决之法，就是让上面的Fragment的根布局吃掉事件，为每个根ViewGroup添加onClick=“true”。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>与第三方Activity交互。与第三方交互，仍要采用Android的标准startActivityForResult()和onActivityResult()这二个方法来进行。但对于Fragment有些事情需要注意，Fragment也有这二个方法，但是为了能正确的让Fragment收到onActivityResult()，需要：</p>
<p>1、宿主Activity要实现一个空的onActivityResult()，里面调用super.onActivityResult()</p>
<p>2、调用Fragment#startActivityForResult()而不是用Activity的 当然，也可以直接使用Activity的startActivityForResult()，那样的话，就只能在宿主Activity里处理返回的结果了。</p>
</blockquote>
<h3 id="Fragment-Arguments"><a href="#Fragment-Arguments" class="headerlink" title="Fragment Arguments"></a>Fragment Arguments</h3><blockquote>
<p>像普通的类一样，Fragment 拥有自己的构造函数，于是我们可以像下面这样在 Activity 中创建 Fragment 实例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainFragment mainFragment = new MainFragment();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要在创建 Fragment 实例时传递参数进行初始化的话，可以创建一个带参数的构造函数，并初始化 Fragment 成员变量等。这样做，看似没有问题，但在一些特殊状况下还是有问题的。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>我们知道，Activity 在一些特殊状况下会发生 destroy 并重新 create 的情形，比如屏幕旋转、内存吃紧时；对应的，依附于 Activity 存在的 Fragment 也会发生类似的状况。而一旦重新 create 时，Fragment 便会调用默认的无参构造函数，导致无法执行有参构造函数进行初始化工作。</p>
</blockquote>
<p>创建通用实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ContentFragment extends Fragment  &#123;  </span><br><span class="line">  </span><br><span class="line">    private String mArgument;  </span><br><span class="line">    public static final String ARGUMENT = &quot;argument&quot;;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onCreate(Bundle savedInstanceState)  &#123;  </span><br><span class="line">        super.onCreate(savedInstanceState);  </span><br><span class="line">        // mArgument = getActivity().getIntent().getStringExtra(ARGUMENT);  </span><br><span class="line">        Bundle bundle = getArguments();  </span><br><span class="line">        if (bundle != null)  </span><br><span class="line">            mArgument = bundle.getString(ARGUMENT);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 传入需要的参数，设置给arguments </span><br><span class="line">     * @param argument </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static ContentFragment newInstance(String argument)  &#123;  </span><br><span class="line">        Bundle bundle = new Bundle();  </span><br><span class="line">        bundle.putString(ARGUMENT, argument);  </span><br><span class="line">        ContentFragment contentFragment = new ContentFragment();  </span><br><span class="line">        contentFragment.setArguments(bundle);  </span><br><span class="line">        return contentFragment;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方便复用</p>
<h3 id="Fragment的startActivityForResult"><a href="#Fragment的startActivityForResult" class="headerlink" title="Fragment的startActivityForResult"></a>Fragment的startActivityForResult</h3><p>这个我是在鸿洋的博客里面看到用途的，但是我觉得那应该仅供学习参考，用途上我更倾向于用EventBus这一类的事件总线（原谅我不上进）；</p>
<h3 id="FragmentPagerAdapter与FragmentStatePagerAdapter"><a href="#FragmentPagerAdapter与FragmentStatePagerAdapter" class="headerlink" title="FragmentPagerAdapter与FragmentStatePagerAdapter"></a>FragmentPagerAdapter与FragmentStatePagerAdapter</h3><blockquote>
<p>FragmentPagerAdapter：对于不再需要的fragment，选择调用detach方法，仅销毁视图，并不会销毁fragment实例。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>FragmentStatePagerAdapter：会销毁不再需要的fragment，当当前事务提交以后，会彻底的将fragmeng从当前Activity的FragmentManager中移除，state标明，销毁时，会将其onSaveInstanceState(Bundle outState)中的bundle信息保存下来，当用户切换回来，可以通过该bundle恢复生成新的fragment，也就是说，你可以在onSaveInstanceState(Bundle outState)方法中保存一些数据，在onCreate中进行恢复创建。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>如上所说，使用FragmentStatePagerAdapter当然更省内存，但是销毁新建也是需要时间的。一般情况下，如果你是制作主页面，就3、4个Tab，那么可以选择使用FragmentPagerAdapter，如果你是用于ViewPager展示数量特别多的条目时，那么建议使用FragmentStatePagerAdapter。</p>
</blockquote>
<h3 id="getChildFragmentManager"><a href="#getChildFragmentManager" class="headerlink" title="getChildFragmentManager()"></a>getChildFragmentManager()</h3><blockquote>
<p>在 Activity 嵌入 Fragment 时，需要使用 FragmentManager，通过 Activity 提供的 getFragmentManager() 方法即可获取，用于管理 Activity 里面嵌入的所有一级 Fragment。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>然而有时候，我们会在 Fragment 里面继续嵌套二级甚至三级 Fragment，即 Activity 嵌套多级 Fragment。此时在 Fragment 里管理子 Fragment 时，也需要使用到 FragmentManager。但是一定要使用 getChildFragmentManager() 方法获取 FragmentManager 对象！</p>
</blockquote>
<h3 id="管理Fragment"><a href="#管理Fragment" class="headerlink" title="管理Fragment"></a>管理Fragment</h3><blockquote>
<p>可以通过FragmentManager做一些事情, 包括: 使用findFragmentById()(用于在activity layout中提供一个UI的fragment)或findFragmentByTag()(适用于有或没有UI的fragment)获取activity中存在的fragment。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>将fragment从后台堆栈中弹出, 使用 popBackStack() (模拟用户按下BACK 命令)。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>使用addOnBackStackChangeListener()注册一个监听后台堆栈变化的listener。</p>
</blockquote>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>DialogFragment<br>显示一个浮动的对话框。使用这个类创建对话框是替代activity创建对话框的最佳选择。因为可以把fragmentdialog<br>放入到activity的返回栈中，使用户能再返回到这个对话框。</p>
<p>ListFragment<br>显示一个列表控件，就像ListActivity类，它提供了很多管理列表的方法，比如onListItemClick()方法响应click事件。</p>
<p>PreferenceFragment<br>显示一个由Preference对象组成的列表，与PreferenceActivity相同。它用于为程序创建“设置”activity。</p>
<p>WebViewFragement<br>WebView 界面的 Fragement;</p>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h3><blockquote>
<p>commit()方法并不立即执行transaction中包含的动作,而是把它加入到UI线程队列中.<br>如果想要立即执行,可以在commit之后立即调用FragmentManager的executePendingTransactions()方法.</p>
</blockquote>
<p><br></p>
<blockquote>
<p>commit()方法必须在状态存储之前调用,否则会抛出异常,如果觉得状态丢失没关系,可以调用commitAllowingStateLoss(). 但是除非万不得已, 一般不推荐用这个方法, 会掩盖很多错误.</p>
</blockquote>
<h3 id="DialogFragment—setTargetFragment"><a href="#DialogFragment—setTargetFragment" class="headerlink" title="DialogFragment—setTargetFragment"></a>DialogFragment—setTargetFragment</h3><p>这个方法，一般就是用于当前fragment由别的fragment启动，在完成操作后返回数据的</p>
<p>从鸿洋大神博客摘抄的一个说明demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class ContentFragment extends Fragment  &#123;  </span><br><span class="line">  </span><br><span class="line">    private String mArgument;  </span><br><span class="line">    public static final String ARGUMENT = &quot;argument&quot;;  </span><br><span class="line">    public static final String RESPONSE = &quot;response&quot;;  </span><br><span class="line">    public static final String EVALUATE_DIALOG = &quot;evaluate_dialog&quot;;  </span><br><span class="line">    public static final int REQUEST_EVALUATE = 0X110;  </span><br><span class="line">  </span><br><span class="line">    //...  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container,  </span><br><span class="line">            Bundle savedInstanceState)  &#123;  </span><br><span class="line">        Random random = new Random();  </span><br><span class="line">        TextView tv = new TextView(getActivity());  </span><br><span class="line">        ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(  </span><br><span class="line">                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);  </span><br><span class="line">        tv.setLayoutParams(params);  </span><br><span class="line">        tv.setText(mArgument);  </span><br><span class="line">        tv.setGravity(Gravity.CENTER);  </span><br><span class="line">        tv.setBackgroundColor(Color.argb(random.nextInt(100),  </span><br><span class="line">                random.nextInt(255), random.nextInt(255), random.nextInt(255)));  </span><br><span class="line">        // set click  </span><br><span class="line">        tv.setOnClickListener(new OnClickListener()  &#123;  </span><br><span class="line">  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onClick(View v)  &#123;  </span><br><span class="line">                EvaluateDialog dialog = new EvaluateDialog();  </span><br><span class="line">                //注意setTargetFragment  </span><br><span class="line">                dialog.setTargetFragment(ContentFragment.this, REQUEST_EVALUATE);  </span><br><span class="line">                dialog.show(getFragmentManager(), EVALUATE_DIALOG);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        return tv;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    //接收返回回来的数据  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onActivityResult(int requestCode, int resultCode, Intent data)  &#123;  </span><br><span class="line">        super.onActivityResult(requestCode, resultCode, data);  </span><br><span class="line">  </span><br><span class="line">        if (requestCode == REQUEST_EVALUATE)  &#123;  </span><br><span class="line">            String evaluate = data  </span><br><span class="line">                    .getStringExtra(EvaluateDialog.RESPONSE_EVALUATE);  </span><br><span class="line">            Toast.makeText(getActivity(), evaluate, Toast.LENGTH_SHORT).show();  </span><br><span class="line">            Intent intent = new Intent();  </span><br><span class="line">            intent.putExtra(RESPONSE, evaluate);  </span><br><span class="line">            getActivity().setResult(Activity.REQUEST_OK, intent);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class EvaluateDialog extends DialogFragment  &#123;  </span><br><span class="line">    private String[] mEvaluteVals = new String[] &#123; &quot;GOOD&quot;, &quot;BAD&quot;, &quot;NORMAL&quot; &#125;;  </span><br><span class="line">    public static final String RESPONSE_EVALUATE = &quot;response_evaluate&quot;;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Dialog onCreateDialog(Bundle savedInstanceState)  &#123;  </span><br><span class="line">        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());  </span><br><span class="line">  </span><br><span class="line">        builder.setTitle(&quot;Evaluate :&quot;).setItems(mEvaluteVals,  </span><br><span class="line">                new OnClickListener()  </span><br><span class="line">                &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void onClick(DialogInterface dialog, int which)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        setResult(which);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">        return builder.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 设置返回数据  </span><br><span class="line">    protected void setResult(int which)  &#123;  </span><br><span class="line">        // 判断是否设置了targetFragment  </span><br><span class="line">        if (getTargetFragment() == null)  </span><br><span class="line">            return;  </span><br><span class="line">  </span><br><span class="line">        Intent intent = new Intent();  </span><br><span class="line">        intent.putExtra(RESPONSE_EVALUATE, mEvaluteVals[which]);  </span><br><span class="line">        getTargetFragment().onActivityResult(ContentFragment.REQUEST_EVALUATE,  </span><br><span class="line">                Activity.RESULT_OK, intent);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为fragment提供了ID有三种方法"><a href="#为fragment提供了ID有三种方法" class="headerlink" title="为fragment提供了ID有三种方法"></a>为fragment提供了ID有三种方法</h3><blockquote>
<p>1、用android:id属性提供一个唯一的标识<br>2、用android:tag属性提供一个唯一的字符串。<br>3、如果上述两种属性都没有，系统会使用其容器视图（view）的ID。</p>
</blockquote>
<h3 id="inflate"><a href="#inflate" class="headerlink" title="inflate()"></a>inflate()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123;　</span><br><span class="line">          // Inflate the layout for this fragment</span><br><span class="line">         return inflater.inflate(R.layout.example_fragment, container, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inflate()函数需要以下三个参数：<br>(1).要inflate的布局的资源Id<br>(2).被inflate的布局的父ViewGroup<br>(3).一个布尔值，表明在inflate期间被inflate的布局是否应该附上ViewGroup（第二个参数container）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup）</p>
<h3 id="Fragment状态的持久化："><a href="#Fragment状态的持久化：" class="headerlink" title="Fragment状态的持久化："></a>Fragment状态的持久化：</h3><blockquote>
<p>由于Activity会经常性的发生配置变化，所以依附它的Fragment就有需要将其状态保存起来问题。下面有两种常用的方法去将Fragment的状态持久化。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>方法一<br>可以通过protected void onSaveInstanceState(Bundle outState),protected void onRestoreInstanceState(Bundle savedInstanceState)状态保存和恢复的方法将状态持久化。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>方法二（更为方便，让Android自动帮我们保存Fragment状态）</p>
<p><1>.我们只需要将Fragment在Activity中作为一个变量整个保存，只要保存了Fragment，那么Fragment的状态就得到保存了，所以我们就可以通过下面方法，进行获取Fragment数据。</1></p>
<p>FragmentManager.putFragment(Bundle bundle, String key, Fragment<br>fragment) 是在Activity中保存Fragment的方法。<br>FragmentManager.getFragment(Bundle bundle, String key)<br>是在Activity中获取所保存的Frament的方法。</p>
<p><2>.很显然，上述<1>中的key就传入Fragment的id，fragment就是你要保存状态的fragment，但，我们注意到上面的两个方法，第一个参数都是Bundle，这就意味着FragmentManager是通过Bundle去保存Fragment的。但是，这个方法仅仅能够保存Fragment中的控件状态，比如说：EditText中用户已经输入的文字（注意：在这里，控件需要设置一个id值，否则Android将不会为我们保存该控件的状态），而Fragment中需要持久化的变量依然会丢失，但依然有解决方法，就是利用方法一！</1></2></p>
<p><3>.下面给出状态的持久化实例代码：</3></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/** Activity中的代码 **/</span><br><span class="line">  FragmentB fragmentB;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.fragment_activity);</span><br><span class="line">     if( savedInstanceState != null )&#123;</span><br><span class="line">         fragmentB = (FragmentB) getSupportFragmentManager()</span><br><span class="line">                     .getFragment(savedInstanceState,&quot;fragmentB&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     init();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">     if( fragmentB != null )&#123;</span><br><span class="line">        getSupportFragmentManager()</span><br><span class="line">          .putFragment(outState,&quot;fragmentB&quot;,fragmentB);</span><br><span class="line">     &#125;</span><br><span class="line">     super.onSaveInstanceState(outState);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /** Fragment中保存变量的代码 **/</span><br><span class="line"> @Nullable</span><br><span class="line"> @Override</span><br><span class="line"> public View onCreateView(LayoutInflater inflater, @Nullable </span><br><span class="line">     ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">     AppLog.e(&quot;onCreateView&quot;);</span><br><span class="line">     if ( null != savedInstanceState )&#123;</span><br><span class="line">         String savedString = savedInstanceState</span><br><span class="line">                              .getString(&quot;string&quot;);</span><br><span class="line">         //得到保存下来的string</span><br><span class="line">     &#125;</span><br><span class="line">     View root = inflater.inflate(R.layout.fragment_a,null);</span><br><span class="line">     return root;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">     outState.putString(&quot;string&quot;,&quot;anAngryAnt&quot;);</span><br><span class="line">     super.onSaveInstanceState(outState);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="commitAllowingStateLoss-和commit"><a href="#commitAllowingStateLoss-和commit" class="headerlink" title="commitAllowingStateLoss()和commit()"></a>commitAllowingStateLoss()和commit()</h3><p><a href="http://blog.csdn.net/freelander_j/article/details/52925745" target="_blank" rel="noopener">源码分析commitAllowingStateLoss() 和commit()的区别</a><br><a href="https://www.cnblogs.com/kissazi2/p/4181093.html" target="_blank" rel="noopener">Fragment提交transaction导致state loss异常</a></p>
<blockquote>
<p>使用Fragment的时候偶尔会有这么一个报错，Can not perform this action after onSaveInstanceState，意思为无法再onSaveInstanceState之后执行该操作，这个操作就是指commit()</p>
</blockquote>
<p><br></p>
<blockquote>
<p>为什么我们会有这种报错呢，因为我们在使用add(),remove(),replace()等方法将Fragment的变化添加进去，然后在通过commit去提交这些变化（另外，在commit之前可以去调用addToBackState()方法，将这些变化加入到activity管理的back stack中去，这样用户调用返回键就可以回退这些变化了），提交完成之后这些变化就会应用到我们的Fragment中去。但是，这个commit()方法，你只能在avtivity存储他的状态之前调用，也就是onSaveInstanceState()，我们都知道activity有一个保存状态的方法和恢复状态的方法，这个就不详细解释了，在onSaveInstanceState()方法之后去调用commit()，就会抛出我们遇到的这个异常，这是因为在onSaveInstanceState()之后调用commit()方法，这些变化就不会被activity存储，即这些状态会被丢失，但我们可以去用commitAllowingStateLoss()这个方法去代替commit()来解决这个为题</p>
</blockquote>
<p>stackoverflows上的一个回答：</p>
<blockquote>
<p>Try moving your transactions into onPostResume() instead (note that onPostResume() is always called after onResume() and onResume() is always called after onActivityResult())</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private boolean mReturningWithResult = false;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    mReturningWithResult = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onPostResume() &#123;</span><br><span class="line">    super.onPostResume();</span><br><span class="line">    if (mReturningWithResult) &#123;</span><br><span class="line">        // Commit your transactions here.</span><br><span class="line">    &#125;</span><br><span class="line">    // Reset the boolean flag back to false for next time.</span><br><span class="line">    mReturningWithResult = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findFragmentById-findFragmentByTag"><a href="#findFragmentById-findFragmentByTag" class="headerlink" title="findFragmentById/findFragmentByTag"></a>findFragmentById/findFragmentByTag</h3><blockquote>
<p>manager.findFragmentById(); //根据ID来找到对应的Fragment实例，主要用在静态添加fragment的布局中，因为静态添加的fragment才会有ID</p>
</blockquote>
<p><br></p>
<blockquote>
<p>manager.findFragmentByTag();//根据TAG找到对应的Fragment实例，主要用于在动态添加的fragment中，根据TAG来找到fragment实例</p>
</blockquote>
<p><br></p>
<blockquote>
<p>manager.getFragments();//获取所有被ADD进Activity中的Fragment</p>
</blockquote>
<p>设置TAG：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction    add(int containerViewId, Fragment fragment, String tag)</span><br><span class="line"></span><br><span class="line">android.app.FragmentTransaction.replace(int containerViewId, Fragment fragment, String tag)</span><br></pre></td></tr></table></figure>
<p>此时用户指定tag，</p>
<blockquote>
<p>然后根据tag获取fragment对象<br>getActivity().getFragmentManager().findFragmentByTag(getFragmentTag(position));</p>
</blockquote>
<h3 id="避免同一activity下-多个fragment-切换时重复执行onCreateView方法"><a href="#避免同一activity下-多个fragment-切换时重复执行onCreateView方法" class="headerlink" title="避免同一activity下 多个fragment 切换时重复执行onCreateView方法"></a>避免同一activity下 多个fragment 切换时重复执行onCreateView方法</h3><blockquote>
<p>Fragment之间切换时每次都会调用onCreateView方法，导致每次Fragment的布局都重绘，无法保持Fragment原有状态。解决办法：在Fragment onCreateView方法中缓存View</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private View rootView;//缓存Fragment view  </span><br><span class="line">   @Override  </span><br><span class="line">   public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </span><br><span class="line">       if(rootView==null)&#123;  </span><br><span class="line">           rootView=inflater.inflate(R.layout.tab_fragment, null);  </span><br><span class="line">       &#125;  </span><br><span class="line">//缓存的rootView需要判断是否已经被加过parent， 如果有parent需要从parent删除，要不然会发生这个rootview已经有parent的错误。  </span><br><span class="line">       ViewGroup parent = (ViewGroup) rootView.getParent();  </span><br><span class="line">       if (parent != null) &#123;  </span><br><span class="line">           parent.removeView(rootView);  </span><br><span class="line">       &#125;   </span><br><span class="line">       return rootView;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="转场动画-setCustomAnimations"><a href="#转场动画-setCustomAnimations" class="headerlink" title="转场动画 setCustomAnimations"></a>转场动画 setCustomAnimations</h3><blockquote>
<p>Fragment的设置需要在transaction.add 或transaction.remove之前。<br>Fragment有两种方式，一种android提供了默认方法，一种自定义动画</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//淡入淡出的默认动画</span><br><span class="line">transaction = getSupportFragmentManager().beginTransaction();</span><br><span class="line">transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);</span><br><span class="line"></span><br><span class="line">//设置自定义过场动画</span><br><span class="line">transaction.setCustomAnimations(            </span><br><span class="line">            R.anim.push_left_in,</span><br><span class="line">            R.anim.push_left_out,</span><br><span class="line">            R.anim.push_left_in,</span><br><span class="line">            R.anim.push_left_out);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动画文件放置位置： res/anim： 这是兼容API-11以下的，只能有四种补间动画方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//push_left_in_no_alpha，acitivity转场的时候用alpha会不好看</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;200&quot;</span><br><span class="line">        android:fromXDelta=&quot;100%p&quot;</span><br><span class="line">        android:toXDelta=&quot;0&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">//push_left_out_no_alpha</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;200&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;-100%p&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">//push_right_in_no_alpha</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;200&quot;</span><br><span class="line">        android:fromXDelta=&quot;-100%p&quot;</span><br><span class="line">        android:toXDelta=&quot;0&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">//push_right_out_no_alpha</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;200&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;100%p&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用set标签的意思是可以集合多个动画一起执行，也可以自行选择单个动画，如alpha等。</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/e6b0475320fc" target="_blank" rel="noopener">Activity和Fragment的转场动画</a></p>
<p>遗留问题：<br>1、单Activity+多Fragment</p>
<p><br><br><br><br><br><br><br><br><br></p>
<hr>
<p>参考博客：</p>
<p><a href="https://www.cnblogs.com/travellife/p/qian-tan-Fragment-sheng-ming-zhou-qi.html" target="_blank" rel="noopener">浅谈 Fragment 生命周期</a><br><a href="http://blog.csdn.net/u013008419/article/details/47948703" target="_blank" rel="noopener">fragment中的attach/detach方法说明(网上拷贝，只为作笔记)</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/37970961" target="_blank" rel="noopener">Android Fragment 真正的完全解析（上）</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/37992017" target="_blank" rel="noopener"> Android Fragment 真正的完全解析（下）</a><br><a href="https://www.baidu.com/link?url=d4GTgEgdc4PHoyQgi3oDPwFgjDMoR_FhJgIDGLGqVn-KSBYdFGj4cbcagKnVTvYT&amp;wd=&amp;eqid=b85ea38e0005e7ec000000035a438707" target="_blank" rel="noopener">Android开发之Fragment回退栈</a><br><a href="https://www.cnblogs.com/cr330326/p/5712022.html" target="_blank" rel="noopener">对于Fragment的一些理解</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/42628537/" target="_blank" rel="noopener">Android Fragment 你应该知道的一切</a><br><a href="https://www.jianshu.com/p/465f645adac0" target="_blank" rel="noopener">Android Fragment 的使用，一些你不可不知的注意事项</a><br><a href="http://www.jb51.net/article/40108.htm" target="_blank" rel="noopener">Android基础之使用Fragment控制切换多个页面</a><br><a href="http://blog.csdn.net/u012386435/article/details/52277274" target="_blank" rel="noopener">Android中Fragment的详解和使用。</a><br><a href="https://www.jianshu.com/p/73503a9a0df8" target="_blank" rel="noopener">Android Fragment使用(一) 基础篇 温故知新</a><br><a href="https://juejin.im/entry/58ce061c44d904006904a776" target="_blank" rel="noopener">Android–Fragment 你应该明白的一些疑难点</a><br><a href="http://www.paincker.com/fragment-visibility" target="_blank" rel="noopener">Android Fragment可见性的判断与监听完全实现</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0605/2996.html" target="_blank" rel="noopener">Square：从今天开始抛弃Fragment吧！</a><br><a href="https://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">Fragment全解析系列（一）：那些年踩过的坑</a><br><a href="https://www.jianshu.com/p/fd71d65f0ec6" target="_blank" rel="noopener">Fragment全解析系列（二）：正确的使用姿势</a><br><a href="https://www.jianshu.com/p/38f7994faa6b" target="_blank" rel="noopener">Fragment之我的解决方案：Fragmentation</a><br><a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">Fragmentation</a><br><a href="https://juejin.im/post/5a39be86f265da432a7bb817" target="_blank" rel="noopener">基于AOP设计的Fragment框架</a><br><a href="https://github.com/JustKiddingBaby/FragmentRigger" target="_blank" rel="noopener">FragmentRigger</a><br><a href="https://www.jianshu.com/p/78ec81b42f92" target="_blank" rel="noopener">从源码角度分析，为什么会发生Fragment重叠？</a><br><a href="https://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="noopener">9行代码让你App内的Fragment对重叠说再见</a><br><a href="http://www.binkery.com/archives/492.html" target="_blank" rel="noopener">Android Fragment 和 FragmentManager 的代码分析</a><br><a href="http://blog.csdn.net/stoppig/article/details/31776607" target="_blank" rel="noopener">FragmentTransaction的commit和commitAllowingStateLoss的区别</a><br><a href="http://blog.csdn.net/sumsear/article/details/77712128" target="_blank" rel="noopener">commitallowingstateloss 和commit的区别</a><br><a href="http://blog.csdn.net/freelander_j/article/details/52925745" target="_blank" rel="noopener">源码分析commitAllowingStateLoss() 和commit()的区别</a><br><a href="https://www.cnblogs.com/kissazi2/p/4181093.html" target="_blank" rel="noopener">Fragment提交transaction导致state loss异常</a><br><a href="https://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult" target="_blank" rel="noopener">stackoverflow-“Failure Delivering Result ” - onActivityForResult</a><br><a href="https://www.2cto.com/kf/201503/386389.html" target="_blank" rel="noopener">Android中保存和恢复Fragment状态的最好方法</a><br><a href="http://blog.csdn.net/qq_16247851/article/details/52793061" target="_blank" rel="noopener">Fragment 出栈的方法popBackStack需要特别注意的一点</a><br><a href="http://blog.csdn.net/yzy1226466341/article/details/51217906" target="_blank" rel="noopener">避免同一activity下 多个fragment 切换时重复执行onCreateView方法</a><br><a href="https://www.jianshu.com/p/e6b0475320fc" target="_blank" rel="noopener">Activity和Fragment的转场动画</a><br><a href="http://blog.csdn.net/u012702547/article/details/49786417" target="_blank" rel="noopener">关于Fragment与Fragment、Activity通信的四种方式</a></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/28/Fragment的了解与学习/" data-id="cjbq9tdfi0001m4iydadj2o6o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/12/08/帮助说明文档/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">帮助说明文档</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    <meta charset="utf-8">

  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
		<div style="margin-top:30px"></div>
		<div style="width:100px;height:100px;margin: 0 auto">
		<img style="width:100%;height:100%" src="/img/QQ.png"/>
		</div>
		<div style="text-align:center;margin-top:20px;color:#000;font-size:15px;margin-bottom:20px;">落叶飘离愁，深思故人秋</div>
      邮箱：xiey94@qq.com<br/>
      微博：<a href="https://weibo.com/3884469910/profile?rightmod=1&wvr=6&mod=personinfo">Xiey94</a><br/>
	  CSDN：<a href="http://my.csdn.net/xiey94">xiey94</a><br/>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/28/Fragment的了解与学习/">Fragment的了解与学习</a>
          </li>
        
          <li>
            <a href="/2017/12/08/帮助说明文档/">帮助说明文档</a>
          </li>
        
          <li>
            <a href="/2017/12/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo-UI教程/">Hexo UI教程</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo-UI使用说明/">Hexo UI使用说明</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo-UI使用说明/" style="font-size: 10px;">Hexo UI使用说明</a> <a href="/tags/android/" style="font-size: 10px;">android</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 xiey94<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>